const createVBO = (gl, data) => {    const buffer = gl.createBuffer();    if (data.length > 0) {        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);    }    gl.bindBuffer(gl.ARRAY_BUFFER, null);    return buffer;};const updateVBO = (gl, vbo, data) => {    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);};const createEBO = (gl, data) => {    const buffer = gl.createBuffer();    if (data.length > 0) {        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), gl.STATIC_DRAW);    }    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);    return buffer;};const updateEBO = (gl, vbo, data) => {    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vbo);    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), gl.STATIC_DRAW);};export { createVBO, updateVBO, createEBO, updateEBO };export class Camera {    translation;    rotation;    scale;    projectionMatrix;    viewMatrix;    constructor() {        this.translation = [0, 0, 0];        this.rotation = [0, 0, 0];        this.scale = [1, 1, 1];    }}class OrthographicCamera extends Camera {    left;    right;    bottom;    top;    near;    far;    constructor(left, right, bottom, top, near = 1, far = -1) {        super();        this.set(left, right, bottom, top, near, far);    }    set(left, right, bottom, top, near = 1, far) {        this.left = left;        this.right = right;        this.bottom = bottom;        this.top = top;        this.near = near;        this.far = far;    }    update() {        this.projectionMatrix = [            2 / (this.right - this.left), 0, 0, 0,            0, 2 / (this.top - this.bottom), 0, 0,            0, 0, 2 / (this.near - this.far), 0,            (this.left + this.right) / (this.left - this.right),            (this.bottom + this.top) / (this.bottom - this.top),            (this.near + this.far) / (this.near - this.far),            1,        ];        let m = Mat4.zRotate(Mat4.identity(), this.rotation[2]);        m = Mat4.yRotate(m, this.rotation[1]);        m = Mat4.xRotate(m, this.rotation[0]);        m = Mat4.scale(m, ...this.scale);        m = Mat4.translate(m, ...this.translation);        this.viewMatrix = Mat4.inverse(m);    }}class PerspectiveCamera extends Camera {    constructor() {        super();    }    update() {    }}export { OrthographicCamera };export class Clock {    #lastTime;    constructor(autoStart = false) {        if (autoStart)            this.#lastTime = performance.now();    }    now() { return performance.now(); }    getDelta() {        let dt = this.getElapsedTime() * 0.001;        this.#lastTime = this.now();        if (dt > 0.2)            dt = 0;        return dt;    }    getElapsedTime() { return this.now() - this.#lastTime; }    start() { this.#lastTime = performance.now(); }}const imageLoader = (params = {}) => {    const img = new Image();    for (const option in params)        img[option] = params[option];    return new Promise((resolve, reject) => {        img.addEventListener("load", e => { resolve(img); });        img.addEventListener("error", e => { reject(e); });    });};export { imageLoader };const renderer_glAttributes = {    alpha: true,    antialias: true,    depth: true,    failIfMajorPerformanceCaveat: false,    powerPreference: "default",    premultipliedAlpha: true,    preserveDrawingBuffer: false,    stencil: false};class Renderer {    canvas;    width;    height;    camera;    clock;    BASIC_SHADER;    TEXTURE_SHADER;    #gl;    constructor(canvas, width, height) {        this.canvas = canvas;        if (!(this.canvas instanceof HTMLCanvasElement))            throw new Error("Your Browser does not support HTML5 Canvas; Please upgrade to a supported browser");        this.#setSize(width, height);        this.#gl = this.canvas.getContext("webgl", renderer_glAttributes);        if (!this.#gl || !(this.#gl instanceof WebGLRenderingContext))            throw new Error("Failed to initialize webgl 1.0; please upgrade your graphics card");        this.BASIC_SHADER = createBasicShader(this.#gl);        this.TEXTURE_SHADER = createTextureShader(this.#gl);        this.clock = new Clock();        window.addEventListener("resize", e => this.onResize(this.#gl, e));    }    async start() {        const loop = () => {            this.update(this.clock.getDelta());            this.camera.update();            this.#gl.viewport(0, 0, this.width, this.height);            this.#setShaderDefault();            this.draw(this.#gl);            requestAnimationFrame(loop);        };        if (!this.camera)            throw new Error("There is no camera for this renderer");        await this.init(this.#gl);        this.clock.start();        requestAnimationFrame(loop);    }    #setSize(w, h) {        this.width = this.canvas.width = w;        this.height = this.canvas.height = h;    }    #setShaderDefault() {        this.BASIC_SHADER.use();        this.BASIC_SHADER.uniformSetters({            projectionMatrix: this.camera.projectionMatrix,            viewMatrix: this.camera.viewMatrix,        });        this.TEXTURE_SHADER.use();        this.TEXTURE_SHADER.uniformSetters({            projectionMatrix: this.camera.projectionMatrix,            viewMatrix: this.camera.viewMatrix,        });    }    get gl() { return this.#gl; }}export { Renderer };export const Mat4 = {    identity() {        return [            1, 0, 0, 0,            0, 1, 0, 0,            0, 0, 1, 0,            0, 0, 0, 1,        ];    },    translation(tx, ty, tz) {        return [            1, 0, 0, 0,            0, 1, 0, 0,            0, 0, 1, 0,            tx, ty, tz, 1,        ];    },    xRotation(a) {        const c = Math.cos(a);        const s = Math.sin(a);        return [            1, 0, 0, 0,            0, c, s, 0,            0, -s, c, 0,            0, 0, 0, 1,        ];    },    yRotation(a) {        const c = Math.cos(a);        const s = Math.sin(a);        return [            c, 0, -s, 0,            0, 1, 0, 0,            s, 0, c, 0,            0, 0, 0, 1,        ];    },    zRotation(a) {        const c = Math.cos(a);        const s = Math.sin(a);        return [            c, s, 0, 0,            -s, c, 0, 0,            0, 0, 1, 0,            0, 0, 0, 1,        ];    },    scaling(sx, sy, sz) {        return [            sx, 0, 0, 0,            0, sy, 0, 0,            0, 0, sz, 0,            0, 0, 0, 1,        ];    },    ortho(left, right, bottom, top, near, far) {        return [            2 / (right - left), 0, 0, 0,            0, 2 / (top - bottom), 0, 0,            0, 0, 2 / (near - far), 0,            (left + right) / (left - right),            (bottom + top) / (bottom - top),            (near + far) / (near - far),            1,        ];    },    transpose(m) {        return [            m[0], m[4], m[8], m[12],            m[1], m[5], m[9], m[13],            m[2], m[6], m[10], m[14],            m[3], m[7], m[11], m[15],        ];    },    inverse(m) {        const m00 = m[0];        const m01 = m[1];        const m02 = m[2];        const m03 = m[3];        const m10 = m[4];        const m11 = m[5];        const m12 = m[6];        const m13 = m[7];        const m20 = m[8];        const m21 = m[2 * 4 + 1];        const m22 = m[2 * 4 + 2];        const m23 = m[2 * 4 + 3];        const m30 = m[12];        const m31 = m[3 * 4 + 1];        const m32 = m[3 * 4 + 2];        const m33 = m[3 * 4 + 3];        const tmp_0 = m22 * m33;        const tmp_1 = m32 * m23;        const tmp_2 = m12 * m33;        const tmp_3 = m32 * m13;        const tmp_4 = m12 * m23;        const tmp_5 = m22 * m13;        const tmp_6 = m02 * m33;        const tmp_7 = m32 * m03;        const tmp_8 = m02 * m23;        const tmp_9 = m22 * m03;        const tmp_10 = m02 * m13;        const tmp_11 = m12 * m03;        const tmp_12 = m20 * m31;        const tmp_13 = m30 * m21;        const tmp_14 = m10 * m31;        const tmp_15 = m30 * m11;        const tmp_16 = m10 * m21;        const tmp_17 = m20 * m11;        const tmp_18 = m00 * m31;        const tmp_19 = m30 * m01;        const tmp_20 = m00 * m21;        const tmp_21 = m20 * m01;        const tmp_22 = m00 * m11;        const tmp_23 = m10 * m01;        const t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -            (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);        const t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -            (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);        const t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -            (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);        const t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -            (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);        const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);        return [            d * t0,            d * t1,            d * t2,            d * t3,            d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -                (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),            d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -                (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),            d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -                (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),            d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -                (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),            d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -                (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33)),            d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -                (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33)),            d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -                (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33)),            d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -                (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23)),            d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -                (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22)),            d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -                (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02)),            d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -                (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12)),            d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -                (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02))        ];    },    multiply(a, b) {        const a00 = a[0];        const a01 = a[1];        const a02 = a[2];        const a03 = a[3];        const a10 = a[4];        const a11 = a[5];        const a12 = a[6];        const a13 = a[7];        const a20 = a[8];        const a21 = a[2 * 4 + 1];        const a22 = a[2 * 4 + 2];        const a23 = a[2 * 4 + 3];        const a30 = a[12];        const a31 = a[3 * 4 + 1];        const a32 = a[3 * 4 + 2];        const a33 = a[3 * 4 + 3];        const b00 = b[0];        const b01 = b[1];        const b02 = b[2];        const b03 = b[3];        const b10 = b[4];        const b11 = b[5];        const b12 = b[6];        const b13 = b[7];        const b20 = b[8];        const b21 = b[2 * 4 + 1];        const b22 = b[2 * 4 + 2];        const b23 = b[2 * 4 + 3];        const b30 = b[12];        const b31 = b[3 * 4 + 1];        const b33 = b[3 * 4 + 3];        const b32 = b[3 * 4 + 2];        return [            b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,            b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,            b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,            b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,            b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,            b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,            b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,            b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,            b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,            b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,            b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,            b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,            b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,            b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,            b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,            b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,        ];    },    translate(m, tx, ty, tz = 0) {        return Mat4.multiply(m, Mat4.translation(tx, ty, tz));    },    xRotate(m, angleInRadians = 0) {        return Mat4.multiply(m, Mat4.xRotation(angleInRadians));    },    yRotate(m, angleInRadians = 0) {        return Mat4.multiply(m, Mat4.yRotation(angleInRadians));    },    zRotate(m, angleInRadians = 0) {        return Mat4.multiply(m, Mat4.zRotation(angleInRadians));    },    scale(m, sx = 1, sy = 1, sz = 1) {        return Mat4.multiply(m, Mat4.scaling(sx, sy, sz));    },};Math["__proto__"] = {    g: 9.8,    G: 6.67e-11,    degToRad(n) { return n * this.PI / 180; },    radToDeg(n) { return n * 180 / this.PI; },    lerp(a, b, t) { return a + (b - a) * t; },    randRange(a, b) { return this.lerp(a, b, this.random()); },    randInt(a, b) { return ~~(this.randRange(a, b)); }};const Vector2 = {    add(v1, v2) { return [v1[0] + v2[0], v1[1] + v2[1]]; },    sub(v1, v2) {        return [v1[0] - v2[0], v1[1] - v2[1]];    },    scale(v, s) { return [v[0] * s, v[1] * s]; },    negate(v) { return [-v[0], -v[1]]; },    dot(v1, v2) { return [v1[0] * v2[0] + v1[1] * v2[1]]; },    getLength(v) { return Math.hypot(v[0], v[1]); },    normalize(v) {        const l = Vector2.getLength(v);        if (l === 0)            return [0, 0];        return [v[0] / l, v[1] / l];    },    perp(v) { return [-v[1], v[0]]; },    addScale(v1, v2, s) { return [v1[0] + v2[0] * s, v1[1] + v2[1] * s]; },    getAngle(v) { return Math.atan2(v[1], v[0]); },    getDistance(p1, p2) {        return Vector2.getLength(Vector2.sub(p2, p1));    },    fromAngle(a, hyp) {        return Vector2.scale([Math.cos(a), Math.sin(a)], hyp);    },    multiplyMatrix(v, m) {        let dv = v.length < 3 ? [v[0], v[1], 1] : [v[0], v[1], v[2]];        let res = [];        for (let i = 0; i < 3; i++) {            let sum = 0;            for (let j = 0; j < 3; j++)                sum += m[j * 3 + i] * dv[j];            res.push(sum);        }        return res;    }};const vec2 = Vector2;export { vec2, Vector2 };const Vector3 = {    add(v1, v2) { return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]]; },    sub(v1, v2) {        return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];    },    scale(v, s) { return [v[0] * s, v[1] * s, v[2] * s]; },    negate(v) { return [-v[0], -v[1], -v[2]]; },    dot(v1, v2) { return [v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]]; },    getLength(v) { return Math.hypot(v[0], v[1], v[2]); },    normalize(v) {        const l = Vector3.getLength(v);        if (l === 0)            return [0, 0, 0];        return [v[0] / l, v[1] / l, v[2] / l];    },    cross(v1, v2) {        let res = [];        res[0] = v1[1] * v2[2] - v1[2] * v2[1];        res[1] = v1[2] * v2[0] - v1[0] * v2[2];        res[2] = v1[0] * v2[1] - v1[1] * v2[0];        return res;    },    addScale(v1, v2, s) { return [v1[0] + v2[0] * s, v1[1] + v2[1] * s, v1[2] + v2[2] * s]; },    getDistance(p1, p2) {        return Vector3.getLength(Vector3.sub(p2, p1));    },    multiplyMatrix(v, m) {        let dv = v.length < 4 ? [v[0], v[1], v[2], 1] : [v[0], v[1], v[2], v[3]];        let res = [];        for (let i = 0; i < 4; i++) {            let sum = 0;            for (let j = 0; j < 4; j++)                sum += m[j * 4 + i] * dv[j];            res.push(sum);        }        return res;    }};const vec3 = Vector3;export { vec3, Vector3 };const basicShader_vertexSource = `attribute vec3 position;uniform mat4 projectionMatrix;uniform mat4 viewMatrix;uniform mat4 modelMatrix;void main() {    gl_PointSize = 10.0;    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1);}`;const basicShader_fragmentSource = `precision mediump float;uniform vec4 color;void main() {    gl_FragColor = color;}`;const createBasicShader = (gl) => {    return createShader(gl, basicShader_vertexSource, basicShader_fragmentSource);};export { createBasicShader };let LAST_SHADER;const loadAndCompileShader = (gl, shaderType, source) => {    const shader = gl.createShader(shaderType);    gl.shaderSource(shader, source);    gl.compileShader(shader);    const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);    if (success)        return shader;    console.log(gl.getShaderInfoLog(shader));    gl.deleteShader(shader);};const initAttributesAndUniforms = (gl, v, f, program) => {    const attributes = {};    const uniforms = {};    const source = (v + "\n" + f)        .replaceAll(";", "\n")        .split("\n")        .map(str => str.trim());    for (let line of source) {        if (line !== "") {            if (line.startsWith("attribute")) {                const [, type, name] = line.split(" ");                attributes[name] = {                    location: gl.getAttribLocation(program, name),                    type,                };            }            else if (line.startsWith("uniform")) {                const [, type, name] = line.split(" ");                uniforms[name] = {                    location: gl.getUniformLocation(program, name),                    type                };            }        }    }    return [attributes, uniforms];};const setShader = (shader) => {    LAST_SHADER = shader;    LAST_SHADER.use();};const setUniforms = (params = {}) => { LAST_SHADER.uniformSetters(params); };const setAttributes = (params = {}) => { LAST_SHADER.enableAttributes(params); };const createShaderProgram = (gl, vSource, fSource) => {    const vertexShader = loadAndCompileShader(gl, gl.VERTEX_SHADER, vSource);    const fragmentShader = loadAndCompileShader(gl, gl.FRAGMENT_SHADER, fSource);    let program = gl.createProgram();    gl.attachShader(program, vertexShader);    gl.attachShader(program, fragmentShader);    gl.linkProgram(program);    let success = gl.getProgramParameter(program, gl.LINK_STATUS);    if (!success) {        console.log(gl.getProgramInfoLog(program));        gl.deleteProgram(program);        return;    }    return program;};const createShader = (gl, vSource, fSource) => {    const shader = class extends Shader {        constructor() {            super(gl, vSource, fSource);        }    };    return new shader();};class Shader {    vertexSource;    fragmentSource;    program;    attributes;    uniforms;    #gl;    constructor(gl, vertexSource, fragmentSource) {        this.vertexSource = vertexSource;        this.fragmentSource = fragmentSource;        this.program = createShaderProgram(gl, vertexSource, fragmentSource);        const i = initAttributesAndUniforms(gl, this.vertexSource, this.fragmentSource, this.program);        this.attributes = i[0];        this.uniforms = i[1];        this.#gl = gl;    }    enableAttributes(params = {}) {        for (const name in params) {            const p = params[name];            const location = this.attributes[name].location;            const size = p.size || 2;            const type = p.type || this.#gl.FLOAT;            const normalized = p.normalized || false;            const stride = p.stride || 0;            const offset = p.offset || 0;            this.#gl.bindBuffer(this.#gl.ARRAY_BUFFER, p.buffer);            this.#gl.enableVertexAttribArray(location);            this.#gl.vertexAttribPointer(location, size, type, normalized, stride, offset);        }    }    disableAttributes() {        for (const attr in this.attributes)            this.#gl.disableVertexAttribArray(this.attributes[attr].location);    }    uniformSetters(params = {}) {        for (const name in params) {            const { location, type } = this.uniforms[name];            this.set(location, type, params[name]);        }    }    set(location, type, value) {        switch (type) {            case "float":                this.#gl.uniform1f(location, value);                break;            case "vec4":                this.#gl.uniform4fv(location, value);                break;            case "mat4":                this.#gl.uniformMatrix4fv(location, false, value);                break;            case "sampler2D":                console.warn("sampler2D is not implemented yet");                this.#gl.uniform1i(location, value);                break;        }    }    use() { this.#gl.useProgram(this.program); }}export { Shader, createShader, setShader, setUniforms, setAttributes };export class Texture {    unit;    data;    width;    height;    #texture;    #destFormat;    #srcFormat;    #type;    #gl;    constructor(gl, params = {}) {        this.#destFormat = params.destFormat || gl.RGBA;        this.#srcFormat = params.srcFormat || gl.RGBA;        this.#type = params.type || gl.UNSIGNED_BYTE;        this.data = params.data;        this.width = params.width || this.data.width;        this.height = params.height || this.data.height;        this.#texture = gl.createTexture();        gl.bindTexture(gl.TEXTURE_2D, this.#texture);        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);        gl.texImage2D(gl.TEXTURE_2D, 0, this.#destFormat, this.#srcFormat, this.#type, this.data);        gl.bindTexture(gl.TEXTURE_2D, null);        this.#gl = gl;    }    use() { this.#gl.bindTexture(this.#gl.TEXTURE_2D, this.#texture); }}const texture_shader_vertexSource = `attribute vec3 position;attribute vec2 texture;uniform mat4 projectionMatrix;uniform mat4 viewMatrix;uniform mat4 modelMatrix;varying vec2 vTexCoord;void main() {    gl_PointSize = 10.0;    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1);    vTexCoord = texture;}`;const texture_shader_fragmentSource = `precision mediump float;varying vec2 vTexCoord;uniform sampler2D image;void main() {    gl_FragColor = texture2D(image, vTexCoord);}`;const createTextureShader = (gl) => {    return createShader(gl, texture_shader_vertexSource, texture_shader_fragmentSource);};export { createTextureShader };